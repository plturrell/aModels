package regulatory

import (
	"context"
	"fmt"
	"log"
	"sync"
	"time"
)

const (
	// criticalComplianceThreshold marks the minimum compliance score before an audit result is
	// flagged as a critical gap. Balances signal sensitivity with false positives during triage.
	criticalComplianceThreshold = 0.70

	// strengthComplianceThreshold is the score at which a principle is treated as an exemplar
	// for sharing best practices across the organisation.
	strengthComplianceThreshold = 0.95
)

// BCBS239AuditPipeline orchestrates comprehensive BCBS 239 audits using Goose and Deep Research Agent.
// This pipeline automates: compliance checks, gap analysis, remediation planning, and insight generation.
type BCBS239AuditPipeline struct {
	reasoningAgent      *ComplianceReasoningAgent
	graphClient         *BCBS239GraphClient
	gooseAdapter        *GooseAdapter
	deepResearchAdapter *DeepResearchAdapter
	logger              *log.Logger

	// Pipeline state
	// auditResults keeps the last known audit runs keyed by ID. Callers are expected to
	// pull results and prune as needed; long-running deployments should enforce retention
	// policies at the handler layer to avoid unbounded growth.
	auditResults map[string]*AuditResult
	mu           sync.RWMutex
}

// NewBCBS239AuditPipeline creates a new audit pipeline.
func NewBCBS239AuditPipeline(
	reasoningAgent *ComplianceReasoningAgent,
	graphClient *BCBS239GraphClient,
	logger *log.Logger,
) *BCBS239AuditPipeline {
	return &BCBS239AuditPipeline{
		reasoningAgent:      reasoningAgent,
		graphClient:         graphClient,
		gooseAdapter:        reasoningAgent.gooseAdapter,
		deepResearchAdapter: reasoningAgent.deepResearchAdapter,
		logger:              logger,
		auditResults:        make(map[string]*AuditResult),
	}
}

// AuditRequest defines parameters for a BCBS239 audit.
type AuditRequest struct {
	AuditID          string
	Principles       []string // e.g., ["P3", "P4", "P7"]
	Scope            string   // "full", "quick", "targeted"
	ReportPeriod     string
	UseGoose         bool // Enable Goose for autonomous tasks
	UseDeepResearch  bool // Enable Deep Research for comprehensive analysis
	GenerateInsights bool // Generate actionable insights
	AutoRemediate    bool // Let Goose create remediation code/scripts
	Context          map[string]interface{}
}

// AuditResult contains the complete audit results.
type AuditResult struct {
	AuditID   string
	StartTime time.Time
	EndTime   time.Time
	Status    string // "in_progress", "completed", "failed"

	// Audit findings
	PrincipleAudits  []*PrincipleAuditResult
	OverallScore     float64
	ComplianceStatus string // "compliant", "partially_compliant", "non_compliant"

	// Insights and recommendations
	Insights        []*ComplianceInsight
	Recommendations []*Remediation

	// Autonomous outputs
	GooseGeneratedScripts []string // Scripts created by Goose
	ResearchReports       []*ResearchReport

	// Metadata
	ModelsUsed     []string
	ProcessingTime map[string]time.Duration
	// Errors accumulates non-fatal issues from downstream phases; we log and surface them while
	// keeping the audit result available to callers for remediation follow-up.
	Errors []string
}

// PrincipleAuditResult contains audit results for a single principle.
type PrincipleAuditResult struct {
	PrincipleID     string
	PrincipleName   string
	ComplianceScore float64
	Status          string
	ControlsCovered int
	ControlsMissing int
	Gaps            []string
	Evidence        []string
	AnalyzedBy      string // "GNN", "DeepResearch", "Goose", etc.
}

// ComplianceInsight represents an actionable insight.
type ComplianceInsight struct {
	InsightID          string
	Category           string // "risk", "opportunity", "gap", "strength"
	Severity           string // "critical", "high", "medium", "low"
	Title              string
	Description        string
	AffectedPrinciples []string
	Evidence           []string
	Recommendations    []string
	GeneratedBy        string
}

// Remediation represents an actionable remediation plan.
type Remediation struct {
	RemediationID       string
	PrincipleID         string
	Gap                 string
	Recommendation      string
	Priority            string
	EstimatedEffort     string
	AutomationScript    string // Generated by Goose
	ImplementationSteps []string
}

// ResearchReport contains comprehensive research findings.
type ResearchReport struct {
	ReportID    string
	Topic       string
	Summary     string
	KeyFindings []string
	Sources     []string
	Confidence  float64
	GeneratedAt time.Time
}

// RunAudit executes a comprehensive BCBS239 audit pipeline.
func (p *BCBS239AuditPipeline) RunAudit(ctx context.Context, request AuditRequest) (*AuditResult, error) {
	if p.logger != nil {
		p.logger.Printf("Starting BCBS239 audit: %s (scope: %s)", request.AuditID, request.Scope)
	}

	result := &AuditResult{
		AuditID:         request.AuditID,
		StartTime:       time.Now(),
		Status:          "in_progress",
		PrincipleAudits: []*PrincipleAuditResult{},
		Insights:        []*ComplianceInsight{},
		Recommendations: []*Remediation{},
		ModelsUsed:      []string{},
		ProcessingTime:  make(map[string]time.Duration),
		Errors:          []string{},
	}

	// Store result for tracking
	p.mu.Lock()
	p.auditResults[request.AuditID] = result
	p.mu.Unlock()

	// Phase 1: Audit each principle
	if err := p.auditPrinciples(ctx, request, result); err != nil {
		result.Status = "failed"
		result.Errors = append(result.Errors, fmt.Sprintf("Principle audit failed: %v", err))
		return result, err
	}

	// Phase 2: Deep Research for comprehensive analysis (if enabled)
	if request.UseDeepResearch && p.deepResearchAdapter != nil {
		if err := p.runDeepResearchAnalysis(ctx, request, result); err != nil {
			if p.logger != nil {
				p.logger.Printf("Warning: Deep Research failed: %v", err)
			}
			result.Errors = append(result.Errors, fmt.Sprintf("Deep Research: %v", err))
		}
	}

	// Phase 3: Generate insights
	if request.GenerateInsights {
		if err := p.generateInsights(ctx, request, result); err != nil {
			if p.logger != nil {
				p.logger.Printf("Warning: Insight generation failed: %v", err)
			}
			result.Errors = append(result.Errors, fmt.Sprintf("Insights: %v", err))
		}
	}

	// Phase 4: Goose autonomous remediation (if enabled)
	if request.AutoRemediate && request.UseGoose && p.gooseAdapter != nil {
		if err := p.runGooseRemediation(ctx, request, result); err != nil {
			if p.logger != nil {
				p.logger.Printf("Warning: Goose remediation failed: %v", err)
			}
			result.Errors = append(result.Errors, fmt.Sprintf("Goose remediation: %v", err))
		}
	}

	// Phase 5: Calculate overall score and status
	p.calculateOverallScore(result)

	result.EndTime = time.Now()
	result.Status = "completed"

	if p.logger != nil {
		p.logger.Printf("Audit completed: %s (score: %.2f, status: %s, duration: %v)",
			request.AuditID, result.OverallScore, result.ComplianceStatus, result.EndTime.Sub(result.StartTime))
	}

	return result, nil
}

// auditPrinciples audits each BCBS239 principle.
func (p *BCBS239AuditPipeline) auditPrinciples(
	ctx context.Context,
	request AuditRequest,
	result *AuditResult,
) error {
	for _, principleID := range request.Principles {
		startTime := time.Now()

		if p.logger != nil {
			p.logger.Printf("Auditing principle: %s", principleID)
		}

		// Get controls for this principle from graph
		controls, err := p.graphClient.GetPrincipleControls(ctx, principleID)
		if err != nil {
			return fmt.Errorf("failed to get controls for %s: %w", principleID, err)
		}

		// Analyze compliance using graph + GNN
		complianceScore := p.analyzeCompliance(controls, principleID)

		// Identify gaps
		gaps := p.identifyGaps(controls, principleID)

		principleAudit := &PrincipleAuditResult{
			PrincipleID:     principleID,
			PrincipleName:   p.getPrincipleName(principleID),
			ComplianceScore: complianceScore,
			Status:          p.getComplianceStatus(complianceScore),
			ControlsCovered: len(controls),
			ControlsMissing: len(gaps),
			Gaps:            gaps,
			Evidence:        p.extractEvidence(controls),
			AnalyzedBy:      "GNN+Graph",
		}

		result.PrincipleAudits = append(result.PrincipleAudits, principleAudit)
		result.ProcessingTime[principleID] = time.Since(startTime)
	}

	return nil
}

// runDeepResearchAnalysis uses Deep Research Agent for comprehensive analysis.
func (p *BCBS239AuditPipeline) runDeepResearchAnalysis(
	ctx context.Context,
	request AuditRequest,
	result *AuditResult,
) error {
	startTime := time.Now()
	result.ModelsUsed = append(result.ModelsUsed, "DeepResearch")

	for _, principleAudit := range result.PrincipleAudits {
		// Skip compliant principles for deep dive
		if principleAudit.Status == "compliant" {
			continue
		}

		// Construct research query
		question := fmt.Sprintf(`Conduct comprehensive research on BCBS 239 %s (%s).
		
Current compliance score: %.2f
Identified gaps: %v

Research focus:
1. Industry best practices for this principle
2. Common compliance gaps and how to address them
3. Regulatory guidance and interpretations
4. Recommended control frameworks
5. Case studies of successful implementation

Provide detailed, actionable recommendations with citations.`,
			principleAudit.PrincipleID,
			principleAudit.PrincipleName,
			principleAudit.ComplianceScore,
			principleAudit.Gaps,
		)

		// Execute deep research
		modelRequest := ModelQueryRequest{
			QueryType:   "research",
			Question:    question,
			PrincipleID: principleAudit.PrincipleID,
			Context: map[string]interface{}{
				"audit_id":         request.AuditID,
				"compliance_score": principleAudit.ComplianceScore,
				"gaps":             principleAudit.Gaps,
			},
		}

		response, err := p.deepResearchAdapter.Query(ctx, modelRequest)
		if err != nil {
			// Surface the error to the caller so the pipeline can record it and continue operating
			// (partial failure is expected when external agents intermittently fail).
			return err
		}

		// Store research report
		report := &ResearchReport{
			ReportID:    fmt.Sprintf("research-%s-%s", request.AuditID, principleAudit.PrincipleID),
			Topic:       fmt.Sprintf("BCBS 239 %s Compliance", principleAudit.PrincipleID),
			Summary:     response.Answer,
			KeyFindings: p.extractKeyFindings(response.Answer),
			Sources:     response.Sources,
			Confidence:  response.Confidence,
			GeneratedAt: time.Now(),
		}

		result.ResearchReports = append(result.ResearchReports, report)

		if p.logger != nil {
			p.logger.Printf("Deep Research completed for %s (confidence: %.2f, sources: %d)",
				principleAudit.PrincipleID, response.Confidence, len(response.Sources))
		}
	}

	result.ProcessingTime["deep_research"] = time.Since(startTime)
	return nil
}

// generateInsights generates actionable insights from audit results.
func (p *BCBS239AuditPipeline) generateInsights(
	ctx context.Context,
	request AuditRequest,
	result *AuditResult,
) error {
	startTime := time.Now()

	// Analyze patterns across principles
	criticalGaps := []string{}
	strengths := []string{}

	for _, audit := range result.PrincipleAudits {
		if audit.ComplianceScore < criticalComplianceThreshold {
			criticalGaps = append(criticalGaps, fmt.Sprintf("%s: %.2f", audit.PrincipleID, audit.ComplianceScore))
		} else if audit.ComplianceScore >= strengthComplianceThreshold {
			strengths = append(strengths, audit.PrincipleID)
		}
	}

	// Generate critical gap insight
	if len(criticalGaps) > 0 {
		insight := &ComplianceInsight{
			InsightID:          fmt.Sprintf("insight-gaps-%s", request.AuditID),
			Category:           "risk",
			Severity:           "critical",
			Title:              "Critical Compliance Gaps Identified",
			Description:        fmt.Sprintf("Found %d principles with compliance scores below 70%%: %v", len(criticalGaps), criticalGaps),
			AffectedPrinciples: p.extractPrincipleIDs(criticalGaps),
			Evidence:           criticalGaps,
			Recommendations: []string{
				"Prioritize remediation for lowest-scoring principles",
				"Conduct root cause analysis for control gaps",
				"Implement automated monitoring for these areas",
			},
			GeneratedBy: "AuditPipeline",
		}
		result.Insights = append(result.Insights, insight)
	}

	// Generate strength insight
	if len(strengths) > 0 {
		insight := &ComplianceInsight{
			InsightID:          fmt.Sprintf("insight-strengths-%s", request.AuditID),
			Category:           "strength",
			Severity:           "low",
			Title:              "Strong Compliance Areas",
			Description:        fmt.Sprintf("Excellent compliance in %d principles: %v", len(strengths), strengths),
			AffectedPrinciples: strengths,
			Evidence:           []string{fmt.Sprintf("Principles %v scored >= 95%%", strengths)},
			Recommendations: []string{
				"Document best practices from these areas",
				"Share control frameworks with teams managing weaker principles",
				"Maintain current processes and controls",
			},
			GeneratedBy: "AuditPipeline",
		}
		result.Insights = append(result.Insights, insight)
	}

	result.ProcessingTime["insights"] = time.Since(startTime)
	return nil
}

// runGooseRemediation uses Goose to autonomously create remediation plans and scripts.
func (p *BCBS239AuditPipeline) runGooseRemediation(
	ctx context.Context,
	request AuditRequest,
	result *AuditResult,
) error {
	startTime := time.Time{}
	result.ModelsUsed = append(result.ModelsUsed, "Goose")

	for _, audit := range result.PrincipleAudits {
		// Only remediate non-compliant areas
		if audit.Status == "compliant" {
			continue
		}

		startTime = time.Now()

		for _, gap := range audit.Gaps {
			// Construct Goose task
			task := fmt.Sprintf(`You are a BCBS 239 compliance automation specialist. 

TASK: Create remediation automation for this compliance gap:

Principle: %s (%s)
Gap: %s
Current Score: %.2f

DELIVERABLES:
1. Write a Python script to automate the missing control
2. Generate validation tests for the control
3. Create monitoring queries to track compliance
4. Document the implementation steps

Requirements:
- Use Neo4j for data lineage tracking
- Follow BCBS 239 best practices
- Include error handling and logging
- Make scripts production-ready

Generate complete, executable code with inline documentation.`,
				audit.PrincipleID,
				audit.PrincipleName,
				gap,
				audit.ComplianceScore,
			)

			// Execute Goose autonomous task
			modelRequest := ModelQueryRequest{
				QueryType:   "automation",
				Question:    task,
				PrincipleID: audit.PrincipleID,
				Context: map[string]interface{}{
					"audit_id":   request.AuditID,
					"gap":        gap,
					"autonomous": true,
				},
			}

			response, err := p.gooseAdapter.Query(ctx, modelRequest)
			if err != nil {
				if p.logger != nil {
					p.logger.Printf("Goose remediation failed for %s gap '%s': %v", audit.PrincipleID, gap, err)
				}
				continue
			}

			// Store remediation
			remediation := &Remediation{
				RemediationID:       fmt.Sprintf("remedy-%s-%s", audit.PrincipleID, time.Now().Unix()),
				PrincipleID:         audit.PrincipleID,
				Gap:                 gap,
				Recommendation:      response.Answer,
				Priority:            p.getPriority(audit.ComplianceScore),
				EstimatedEffort:     p.estimateEffort(gap),
				AutomationScript:    response.Answer, // Goose-generated code
				ImplementationSteps: p.extractSteps(response.Answer),
			}

			result.Recommendations = append(result.Recommendations, remediation)
			result.GooseGeneratedScripts = append(result.GooseGeneratedScripts, response.Answer)

			if p.logger != nil {
				p.logger.Printf("Goose generated remediation script for %s gap: %s", audit.PrincipleID, gap)
			}
		}
	}

	if !startTime.IsZero() {
		result.ProcessingTime["goose_remediation"] = time.Since(startTime)
	}
	return nil
}

// Helper methods

func (p *BCBS239AuditPipeline) analyzeCompliance(controls []ControlMapping, principleID string) float64 {
	if len(controls) == 0 {
		return 0.0
	}

	// Simple scoring: more controls = better compliance
	// In production, this would analyze control effectiveness
	baseScore := 0.5
	controlBonus := float64(len(controls)) * 0.1

	score := baseScore + controlBonus
	if score > 1.0 {
		score = 1.0
	}

	return score
}

func (p *BCBS239AuditPipeline) identifyGaps(controls []ControlMapping, principleID string) []string {
	gaps := []string{}

	// Expected controls per principle (simplified)
	expectedControls := map[string]int{
		"P3":  5, // Accuracy requires multiple validation controls
		"P4":  4, // Completeness
		"P7":  5, // Reporting accuracy
		"P12": 3, // Supervisory reporting
	}

	expected, exists := expectedControls[principleID]
	if !exists {
		expected = 3 // Default
	}

	if len(controls) < expected {
		gaps = append(gaps, fmt.Sprintf("Missing %d control(s)", expected-len(controls)))
	}

	// Check for specific control types
	hasAutomated := false
	hasManual := false

	for _, control := range controls {
		if control.ControlType == "automated" {
			hasAutomated = true
		}
		if control.ControlType == "manual" {
			hasManual = true
		}
	}

	if !hasAutomated {
		gaps = append(gaps, "No automated controls found")
	}
	if !hasManual {
		gaps = append(gaps, "No manual oversight controls found")
	}

	return gaps
}

func (p *BCBS239AuditPipeline) extractEvidence(controls []ControlMapping) []string {
	evidence := []string{}
	for _, control := range controls {
		evidence = append(evidence, fmt.Sprintf("Control %s: %s", control.ControlID, control.ControlName))
	}
	return evidence
}

func (p *BCBS239AuditPipeline) getPrincipleName(principleID string) string {
	names := map[string]string{
		"P3":  "Accuracy and Integrity",
		"P4":  "Completeness",
		"P5":  "Timeliness",
		"P6":  "Adaptability",
		"P7":  "Accuracy (Reporting)",
		"P12": "Supervisory Reporting",
	}

	if name, ok := names[principleID]; ok {
		return name
	}
	return principleID
}

func (p *BCBS239AuditPipeline) getComplianceStatus(score float64) string {
	if score >= 0.95 {
		return "compliant"
	} else if score >= 0.70 {
		return "partially_compliant"
	}
	return "non_compliant"
}

func (p *BCBS239AuditPipeline) calculateOverallScore(result *AuditResult) {
	if len(result.PrincipleAudits) == 0 {
		result.OverallScore = 0.0
		result.ComplianceStatus = "non_compliant"
		return
	}

	total := 0.0
	for _, audit := range result.PrincipleAudits {
		total += audit.ComplianceScore
	}

	result.OverallScore = total / float64(len(result.PrincipleAudits))
	result.ComplianceStatus = p.getComplianceStatus(result.OverallScore)
}

func (p *BCBS239AuditPipeline) extractKeyFindings(text string) []string {
	// Simple extraction - in production, use NLP
	return []string{
		"See full research report for detailed findings",
	}
}

func (p *BCBS239AuditPipeline) extractPrincipleIDs(gaps []string) []string {
	ids := []string{}
	for _, gap := range gaps {
		// Extract principle ID from "P3: 0.65" format
		if len(gap) >= 2 && gap[0] == 'P' {
			ids = append(ids, gap[:2])
		}
	}
	return ids
}

func (p *BCBS239AuditPipeline) extractSteps(script string) []string {
	return []string{
		"Review generated script",
		"Test in development environment",
		"Deploy to production",
		"Monitor control effectiveness",
	}
}

func (p *BCBS239AuditPipeline) getPriority(score float64) string {
	if score < 0.5 {
		return "critical"
	} else if score < 0.7 {
		return "high"
	} else if score < 0.85 {
		return "medium"
	}
	return "low"
}

func (p *BCBS239AuditPipeline) estimateEffort(gap string) string {
	if len(gap) > 50 {
		return "3-5 days"
	}
	return "1-2 days"
}

// GetAuditStatus retrieves the current status of an audit.
func (p *BCBS239AuditPipeline) GetAuditStatus(auditID string) (*AuditResult, bool) {
	p.mu.RLock()
	defer p.mu.RUnlock()

	result, exists := p.auditResults[auditID]
	return result, exists
}
