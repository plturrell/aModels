//go:build hana

package storage

import (
	"bytes"
	"context"
	"crypto/sha256"
	"database/sql"
	"encoding/json"
	"fmt"
	"math"
	"math/rand"
	"time"

	hdbdriver "github.com/SAP/go-hdb/driver"
)

// HANASearchIndex provides persistent vector storage with differential privacy
type HANASearchIndex struct {
	db            *sql.DB
	privacyConfig *PrivacyConfig
}

// NewHANASearchIndex creates a new HANA search index
func NewHANASearchIndex(dsn string, privacyConfig *PrivacyConfig) (*HANASearchIndex, error) {
	db, err := sql.Open("hdb", dsn)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to HANA: %w", err)
	}

	index := &HANASearchIndex{
		db:            db,
		privacyConfig: privacyConfig,
	}

	// Create tables if they don't exist
	if err := index.createTables(); err != nil {
		return nil, fmt.Errorf("failed to create tables: %w", err)
	}

	return index, nil
}

// createTables creates the necessary HANA tables
func (h *HANASearchIndex) createTables() error {
	ctx := context.Background()

	createEmbeddings := `
CREATE COLUMN TABLE search_embeddings (
	id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	document_id NVARCHAR(255) UNIQUE NOT NULL,
	embedding BLOB,
	content NCLOB,
	metadata NCLOB,
	privacy_level NVARCHAR(20) DEFAULT 'medium',
	created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)`
	if _, err := h.db.ExecContext(ctx, createEmbeddings); err != nil && !isAlreadyExistsError(err) {
		return fmt.Errorf("failed to create search_embeddings table: %w", err)
	}

	createLogs := `
CREATE COLUMN TABLE search_logs (
	id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	query_hash NVARCHAR(64) NOT NULL,
	query_embedding BLOB,
	result_count INTEGER DEFAULT 0,
	top_result_id NVARCHAR(255),
	latency_ms BIGINT DEFAULT 0,
	user_id_hash NVARCHAR(64),
	session_id NVARCHAR(255),
	timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	privacy_budget_used DECIMAL(10,6) DEFAULT 0
)`
	if _, err := h.db.ExecContext(ctx, createLogs); err != nil && !isAlreadyExistsError(err) {
		return fmt.Errorf("failed to create search_logs table: %w", err)
	}

	createClicks := `
CREATE COLUMN TABLE search_clicks (
	id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	query_hash NVARCHAR(64) NOT NULL,
	document_id NVARCHAR(255) NOT NULL,
	position INTEGER DEFAULT 0,
	timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	session_id NVARCHAR(255)
)`
	if _, err := h.db.ExecContext(ctx, createClicks); err != nil && !isAlreadyExistsError(err) {
		return fmt.Errorf("failed to create search_clicks table: %w", err)
	}

	indexes := []string{
		"CREATE INDEX idx_search_embeddings_doc_id ON search_embeddings (document_id)",
		"CREATE INDEX idx_search_logs_query_hash ON search_logs (query_hash)",
		"CREATE INDEX idx_search_clicks_query_hash ON search_clicks (query_hash)",
	}

	for _, stmt := range indexes {
		if _, err := h.db.ExecContext(ctx, stmt); err != nil && !isAlreadyExistsError(err) {
			fmt.Printf("⚠️  Index creation failed: %v\n", err)
		}
	}

	return nil
}

// AddDocument adds a document with privacy controls
func (h *HANASearchIndex) AddDocument(ctx context.Context, docID string, embedding []float64, content string, metadata map[string]interface{}) error {
	if h.privacyConfig == nil {
		return fmt.Errorf("privacy configuration not set")
	}
	// Check privacy budget
	cost := PrivacyBudgetCosts.DocumentAdd
	if !h.privacyConfig.CanPerformOperation(cost) {
		return fmt.Errorf("privacy budget exhausted")
	}

	// Apply differential privacy noise to embedding
	noisyEmbedding := h.addNoiseToEmbedding(embedding)

	// Serialize metadata
	metadataJSON, err := json.Marshal(metadata)
	if err != nil {
		return fmt.Errorf("failed to serialize metadata: %w", err)
	}

	// Insert document
	_, err = h.db.ExecContext(ctx, `
		UPSERT search_embeddings (document_id, embedding, content, metadata, privacy_level)
		VALUES (?, ?, ?, ?, ?) WITH PRIMARY KEY
	`, docID, h.embeddingToBytes(noisyEmbedding), content, string(metadataJSON), h.privacyConfig.PrivacyLevel)

	if err != nil {
		return fmt.Errorf("failed to insert document: %w", err)
	}

	// Update privacy budget
	if err := h.privacyConfig.ConsumeBudget(cost); err != nil {
		return err
	}

	return nil
}

// SearchDocuments searches for similar documents
func (h *HANASearchIndex) SearchDocuments(ctx context.Context, queryEmbedding []float64, topK int) ([]SearchEmbedding, error) {
	if h.privacyConfig == nil {
		return nil, fmt.Errorf("privacy configuration not set")
	}
	// Check privacy budget
	cost := PrivacyBudgetCosts.SearchQuery
	if !h.privacyConfig.CanPerformOperation(cost) {
		return nil, fmt.Errorf("privacy budget exhausted")
	}

	// Apply noise to query embedding
	noisyQuery := h.addNoiseToEmbedding(queryEmbedding)

	// Get all documents (in production, this would use vector similarity search)
	rows, err := h.db.QueryContext(ctx, `
		SELECT id, document_id, embedding, content, metadata, privacy_level, created_at
		FROM search_embeddings
		ORDER BY created_at DESC
		LIMIT ?
	`, topK*2) // Get more than needed for privacy
	if err != nil {
		return nil, fmt.Errorf("failed to query documents: %w", err)
	}
	defer rows.Close()

	var documents []SearchEmbedding
	for rows.Next() {
		var doc SearchEmbedding
		var embeddingBytes []byte
		var contentBuf, metadataBuf bytes.Buffer
		contentLob := hdbdriver.NewLob(nil, &contentBuf)
		metadataLob := hdbdriver.NewLob(nil, &metadataBuf)

		if err := rows.Scan(&doc.ID, &doc.DocumentID, &embeddingBytes, contentLob, metadataLob, &doc.PrivacyLevel, &doc.CreatedAt); err != nil {
			continue
		}

		// Convert embedding bytes back to float64 slice
		doc.Embedding = h.bytesToEmbedding(embeddingBytes)
		doc.Content = contentBuf.String()
		if metadataBuf.Len() > 0 {
			_ = json.Unmarshal(metadataBuf.Bytes(), &doc.Metadata)
		}

		documents = append(documents, doc)
	}

	// Calculate similarities and sort
	similarities := make([]float64, len(documents))
	for i, doc := range documents {
		similarities[i] = h.cosineSimilarity(noisyQuery, doc.Embedding)
	}

	// Sort by similarity (simple bubble sort for small datasets)
	for i := 0; i < len(documents)-1; i++ {
		for j := i + 1; j < len(documents); j++ {
			if similarities[i] < similarities[j] {
				documents[i], documents[j] = documents[j], documents[i]
				similarities[i], similarities[j] = similarities[j], similarities[i]
			}
		}
	}

	// Return top K results
	if topK > 0 && topK < len(documents) {
		documents = documents[:topK]
	}

	// Update privacy budget
	if err := h.privacyConfig.ConsumeBudget(cost); err != nil {
		return nil, err
	}

	return documents, nil
}

// LogSearch logs a search query with privacy
func (h *HANASearchIndex) LogSearch(ctx context.Context, query string, queryEmbedding []float64, resultCount int, topResultID, userID, sessionID string, latencyMs int64) error {
	if h.privacyConfig == nil {
		return fmt.Errorf("privacy configuration not set")
	}
	// Hash query for privacy
	queryHash := h.hashString(query)

	// Hash user ID for privacy
	userIDHash := h.hashString(userID)

	// Apply noise to query embedding
	noisyQuery := h.addNoiseToEmbedding(queryEmbedding)

	// Calculate privacy cost
	privacyCost := 0.03 + float64(resultCount)*0.001

	// Check privacy budget
	if !h.privacyConfig.CanPerformOperation(privacyCost) {
		return fmt.Errorf("privacy budget would be exceeded")
	}

	// Insert search log
	_, err := h.db.ExecContext(ctx, `
		INSERT INTO search_logs (query_hash, query_embedding, result_count, top_result_id, latency_ms, user_id_hash, session_id, privacy_budget_used)
		VALUES (?, ?, ?, ?, ?, ?, ?, ?)
	`, queryHash, h.embeddingToBytes(noisyQuery), resultCount, topResultID, latencyMs, userIDHash, sessionID, privacyCost)

	if err != nil {
		return fmt.Errorf("failed to log search: %w", err)
	}

	// Update privacy budget
	if err := h.privacyConfig.ConsumeBudget(privacyCost); err != nil {
		return err
	}

	return nil
}

// LogClick logs a click-through event
func (h *HANASearchIndex) LogClick(ctx context.Context, query string, documentID string, position int, sessionID string) error {
	if h.privacyConfig == nil {
		return fmt.Errorf("privacy configuration not set")
	}

	cost := PrivacyBudgetCosts.ClickLog
	if !h.privacyConfig.CanPerformOperation(cost) {
		return fmt.Errorf("privacy budget would be exceeded")
	}

	// Hash query for privacy
	queryHash := h.hashString(query)

	// Insert click log
	_, err := h.db.ExecContext(ctx, `
		INSERT INTO search_clicks (query_hash, document_id, position, session_id)
		VALUES (?, ?, ?, ?)
	`, queryHash, documentID, position, sessionID)

	if err != nil {
		return fmt.Errorf("failed to log click: %w", err)
	}

	return nil
}

// GetSearchAnalytics returns search analytics with privacy
func (h *HANASearchIndex) GetSearchAnalytics(ctx context.Context, days int) (map[string]interface{}, error) {
	// Get aggregated statistics
	rows, err := h.db.QueryContext(ctx, `
		SELECT 
			COUNT(*) as total_searches,
			AVG(latency_ms) as avg_latency,
			AVG(result_count) as avg_results,
			SUM(privacy_budget_used) as total_privacy_used
		FROM search_logs 
		WHERE timestamp >= ?
	`, time.Now().AddDate(0, 0, -days))
	if err != nil {
		return nil, fmt.Errorf("failed to get analytics: %w", err)
	}
	defer rows.Close()

	var analytics map[string]interface{}
	if rows.Next() {
		var totalSearches, avgLatency, avgResults, totalPrivacyUsed sql.NullFloat64
		err := rows.Scan(&totalSearches, &avgLatency, &avgResults, &totalPrivacyUsed)
		if err != nil {
			return nil, fmt.Errorf("failed to scan analytics: %w", err)
		}

		analytics = map[string]interface{}{
			"total_searches":           totalSearches.Float64,
			"avg_latency_ms":           avgLatency.Float64,
			"avg_results":              avgResults.Float64,
			"total_privacy_used":       totalPrivacyUsed.Float64,
			"privacy_budget_remaining": h.privacyConfig.PrivacyBudget - h.privacyConfig.UsedBudget,
		}
	}

	return analytics, nil
}

// CleanupOldData removes old data based on retention policy
func (h *HANASearchIndex) CleanupOldData(ctx context.Context) error {
	cutoffDate := time.Now().AddDate(0, 0, -h.privacyConfig.RetentionDays)

	// Clean up old search logs
	_, err := h.db.ExecContext(ctx, `
		DELETE FROM search_logs WHERE timestamp < ?
	`, cutoffDate)
	if err != nil {
		return fmt.Errorf("failed to cleanup search logs: %w", err)
	}

	// Clean up old clicks
	_, err = h.db.ExecContext(ctx, `
		DELETE FROM search_clicks WHERE timestamp < ?
	`, cutoffDate)
	if err != nil {
		return fmt.Errorf("failed to cleanup clicks: %w", err)
	}

	return nil
}

// Close closes the database connection
func (h *HANASearchIndex) Close() error {
	return h.db.Close()
}

// Helper methods

func (h *HANASearchIndex) addNoiseToEmbedding(embedding []float64) []float64 {
	if h.privacyConfig.NoiseLevel <= 0 {
		return embedding
	}

	noisy := make([]float64, len(embedding))
	for i, val := range embedding {
		// Add Laplacian noise
		noise := h.laplaceNoise(h.privacyConfig.NoiseLevel)
		noisy[i] = val + noise
	}

	return noisy
}

func (h *HANASearchIndex) laplaceNoise(epsilon float64) float64 {
	// Generate Laplacian noise
	u := rand.Float64() - 0.5
	if u == 0 {
		u = 0.0001 // Avoid log(0)
	}
	sign := 1.0
	if u < 0 {
		sign = -1.0
	}
	return -sign * math.Log(1-2*math.Abs(u)) / epsilon
}

func (h *HANASearchIndex) cosineSimilarity(a, b []float64) float64 {
	if len(a) != len(b) {
		return 0.0
	}

	var dotProduct, normA, normB float64
	for i := range a {
		dotProduct += a[i] * b[i]
		normA += a[i] * a[i]
		normB += b[i] * b[i]
	}

	if normA == 0 || normB == 0 {
		return 0.0
	}

	return dotProduct / (math.Sqrt(normA) * math.Sqrt(normB))
}

func (h *HANASearchIndex) hashString(s string) string {
	hash := sha256.Sum256([]byte(s))
	return fmt.Sprintf("%x", hash)
}

func (h *HANASearchIndex) embeddingToBytes(embedding []float64) []byte {
	// Convert float64 slice to bytes for HANA storage
	// This is a simplified implementation - in production, use proper serialization
	data, _ := json.Marshal(embedding)
	return data
}

func (h *HANASearchIndex) bytesToEmbedding(data []byte) []float64 {
	var embedding []float64
	_ = json.Unmarshal(data, &embedding)
	return embedding
}
