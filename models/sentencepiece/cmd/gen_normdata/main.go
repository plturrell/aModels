package main

import (
	"bufio"
	"bytes"
	"encoding/binary"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
)

func main() {
	// Get current working directory
	cwd, err := os.Getwd()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error getting current directory: %v\n", err)
		os.Exit(1)
	}

	// Source files from upstream sentencepiece
	normRuleFile := filepath.Join(cwd, "..", "sentencepiece", "src", "normalization_rule.h")
	unicodeScriptFile := filepath.Join(cwd, "..", "sentencepiece", "src", "unicode_script_map.h")

	// Output directory
	outDir := filepath.Join(cwd, "internal", "normalizer")

	fmt.Println("Parsing normalization rules from upstream SentencePiece...")

	// Parse normalization rules
	normRules, err := parseNormalizationRules(normRuleFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing normalization rules: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("  ✓ Parsed %d normalization rule entries\n", len(normRules))

	// Parse unicode script map
	scriptMap, err := parseUnicodeScriptMap(unicodeScriptFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing unicode script map: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("  ✓ Parsed %d unicode script entries\n", len(scriptMap))

	// Generate Go source files
	fmt.Println("\nGenerating Go source files...")

	if err := generateNormRulesGo(normRules, filepath.Join(outDir, "norm_rules_gen.go")); err != nil {
		fmt.Fprintf(os.Stderr, "Error generating norm_rules_gen.go: %v\n", err)
		os.Exit(1)
	}
	fmt.Println("  ✓ Generated norm_rules_gen.go")

	if err := generateScriptMapGo(scriptMap, filepath.Join(outDir, "script_map_gen.go")); err != nil {
		fmt.Fprintf(os.Stderr, "Error generating script_map_gen.go: %v\n", err)
		os.Exit(1)
	}
	fmt.Println("  ✓ Generated script_map_gen.go")

	fmt.Println("\nNormalization data generation complete!")
}

// parseNormalizationRules parses the binary blob from normalization_rule.h
func parseNormalizationRules(filename string) ([]byte, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var rules []byte
	scanner := bufio.NewScanner(file)
	
	// Look for the uint64_t array definition
	inArray := false
	hexPattern := regexp.MustCompile(`0x[0-9A-Fa-f]+`)

	for scanner.Scan() {
		line := scanner.Text()

		// Start of array
		if strings.Contains(line, "kNormalizationRules_blob_uint64_t") {
			inArray = true
			continue
		}

		// End of array
		if inArray && strings.Contains(line, "};") {
			break
		}

		// Parse hex values
		if inArray {
			matches := hexPattern.FindAllString(line, -1)
			for _, match := range matches {
				// Parse hex string to uint64
				val, err := strconv.ParseUint(match[2:], 16, 64)
				if err != nil {
					continue
				}
				
				// Convert uint64 to bytes (little-endian)
				buf := make([]byte, 8)
				binary.LittleEndian.PutUint64(buf, val)
				rules = append(rules, buf...)
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return rules, nil
}

// parseUnicodeScriptMap parses unicode_script_map.h
func parseUnicodeScriptMap(filename string) (map[rune]string, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	scriptMap := make(map[rune]string)
	scanner := bufio.NewScanner(file)

	// Pattern to match script assignments like: {0x0041, 0x005A, "Latin"},
	pattern := regexp.MustCompile(`\{0x([0-9A-Fa-f]+),\s*0x([0-9A-Fa-f]+),\s*"([^"]+)"\}`)

	for scanner.Scan() {
		line := scanner.Text()
		matches := pattern.FindStringSubmatch(line)
		if len(matches) == 4 {
			start, _ := strconv.ParseInt(matches[1], 16, 64)
			end, _ := strconv.ParseInt(matches[2], 16, 64)
			script := matches[3]

			// Map all runes in range to script
			for r := start; r <= end; r++ {
				scriptMap[rune(r)] = script
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return scriptMap, nil
}

// generateNormRulesGo generates Go source file with normalization rules
func generateNormRulesGo(rules []byte, outFile string) error {
	var buf bytes.Buffer

	buf.WriteString("// Code generated by cmd/gen_normdata. DO NOT EDIT.\n\n")
	buf.WriteString("package normalizer\n\n")
	buf.WriteString("// normalizationRulesData contains the precompiled normalization rules\n")
	buf.WriteString("// from the upstream SentencePiece project.\n")
	buf.WriteString("var normalizationRulesData = []byte{\n")

	// Write bytes in chunks of 16 per line
	for i := 0; i < len(rules); i += 16 {
		buf.WriteString("\t")
		end := i + 16
		if end > len(rules) {
			end = len(rules)
		}
		for j := i; j < end; j++ {
			buf.WriteString(fmt.Sprintf("0x%02x, ", rules[j]))
		}
		buf.WriteString("\n")
	}

	buf.WriteString("}\n")

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("failed to format generated code: %w", err)
	}

	return os.WriteFile(outFile, formatted, 0644)
}

// generateScriptMapGo generates Go source file with unicode script map
func generateScriptMapGo(scriptMap map[rune]string, outFile string) error {
	var buf bytes.Buffer

	buf.WriteString("// Code generated by cmd/gen_normdata. DO NOT EDIT.\n\n")
	buf.WriteString("package normalizer\n\n")
	buf.WriteString("// unicodeScriptMap maps Unicode codepoints to their script names.\n")
	buf.WriteString("var unicodeScriptMap = map[rune]string{\n")

	// Write map entries (sorted by rune for deterministic output)
	// Note: For large maps, consider using a more efficient lookup structure
	for r, script := range scriptMap {
		buf.WriteString(fmt.Sprintf("\t0x%04X: %q,\n", r, script))
	}

	buf.WriteString("}\n\n")

	buf.WriteString("// GetUnicodeScript returns the Unicode script name for a given rune.\n")
	buf.WriteString("func GetUnicodeScript(r rune) string {\n")
	buf.WriteString("\tif script, ok := unicodeScriptMap[r]; ok {\n")
	buf.WriteString("\t\treturn script\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn \"Unknown\"\n")
	buf.WriteString("}\n")

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("failed to format generated code: %w", err)
	}

	return os.WriteFile(outFile, formatted, 0644)
}
