//go:build hana

package storage

import (
	"bytes"
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"time"

	hdbdriver "github.com/SAP/go-hdb/driver"
)

// HANADocumentStore provides document storage with privacy controls
type HANADocumentStore struct {
	db            *sql.DB
	privacyConfig *PrivacyConfig
}

// NewHANADocumentStore creates a new HANA document store
func NewHANADocumentStore(dsn string, privacyConfig *PrivacyConfig) (*HANADocumentStore, error) {
	db, err := sql.Open("hdb", dsn)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to HANA: %w", err)
	}

	store := &HANADocumentStore{
		db:            db,
		privacyConfig: privacyConfig,
	}

	// Create tables if they don't exist
	if err := store.createTables(); err != nil {
		return nil, fmt.Errorf("failed to create tables: %w", err)
	}

	return store, nil
}

// createTables creates the necessary HANA tables
func (h *HANADocumentStore) createTables() error {
	ctx := context.Background()

	createDocuments := `
CREATE COLUMN TABLE documents (
	id NVARCHAR(255) PRIMARY KEY,
	content NCLOB,
	metadata NCLOB,
	privacy_level NVARCHAR(20) DEFAULT 'medium',
	created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	access_count BIGINT DEFAULT 0,
	last_accessed TIMESTAMP
)`
	if _, err := h.db.ExecContext(ctx, createDocuments); err != nil && !isAlreadyExistsError(err) {
		if isSyntaxError(err) {
		} else {
			return fmt.Errorf("failed to create documents table: %w", err)
		}
	}

	createVersions := `
CREATE COLUMN TABLE document_versions (
	id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	document_id NVARCHAR(255) NOT NULL,
	content NCLOB,
	metadata NCLOB,
	privacy_level NVARCHAR(20),
	version_number INTEGER DEFAULT 1,
	created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	created_by NVARCHAR(255),
	change_reason NCLOB
)`
	if _, err := h.db.ExecContext(ctx, createVersions); err != nil && !isAlreadyExistsError(err) {
		return fmt.Errorf("failed to create document_versions table: %w", err)
	}

	createAccess := `
CREATE COLUMN TABLE document_access_log (
	id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	document_id NVARCHAR(255) NOT NULL,
	user_id_hash NVARCHAR(64),
	session_id NVARCHAR(255),
	access_type NVARCHAR(50),
	privacy_budget_used DECIMAL(10,6) DEFAULT 0,
	timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	ip_hash NVARCHAR(64)
)`
	if _, err := h.db.ExecContext(ctx, createAccess); err != nil && !isAlreadyExistsError(err) {
		return fmt.Errorf("failed to create document_access_log table: %w", err)
	}

	indexes := []string{
		"CREATE INDEX idx_documents_privacy_level ON documents (privacy_level)",
		"CREATE INDEX idx_documents_created_at ON documents (created_at)",
		"CREATE INDEX idx_document_versions_doc_id ON document_versions (document_id)",
		"CREATE INDEX idx_document_access_doc_id ON document_access_log (document_id)",
	}

	for _, stmt := range indexes {
		if _, err := h.db.ExecContext(ctx, stmt); err != nil && !isAlreadyExistsError(err) {
			fmt.Printf("⚠️  Index creation failed: %v\n", err)
		}
	}

	return nil
}

// StoreDocument stores a document with privacy controls
func (h *HANADocumentStore) StoreDocument(ctx context.Context, doc *Document) error {
	// Check privacy budget
	cost := PrivacyBudgetCosts.DocumentAdd
	if !h.privacyConfig.CanPerformOperation(cost) {
		return fmt.Errorf("privacy budget would be exceeded")
	}

	// Serialize metadata
	metadataJSON, err := json.Marshal(doc.Metadata)
	if err != nil {
		return fmt.Errorf("failed to serialize metadata: %w", err)
	}

	// Store document
	_, err = h.db.ExecContext(ctx, `
		UPSERT documents (id, content, metadata, privacy_level, created_at, updated_at, access_count, last_accessed)
		VALUES (?, ?, ?, ?, ?, ?, ?, ?) WITH PRIMARY KEY
	`, doc.ID, doc.Content, string(metadataJSON), doc.PrivacyLevel, doc.CreatedAt, doc.UpdatedAt, doc.AccessCount, doc.LastAccessed)

	if err != nil {
		return fmt.Errorf("failed to store document: %w", err)
	}

	// Store version for audit trail
	_, err = h.db.ExecContext(ctx, `
		INSERT INTO document_versions (document_id, content, metadata, privacy_level, created_by, change_reason)
		VALUES (?, ?, ?, ?, ?, ?)
	`, doc.ID, doc.Content, string(metadataJSON), doc.PrivacyLevel, "system", "document_created")

	if err != nil {
		return fmt.Errorf("failed to store document version: %w", err)
	}

	// Update privacy budget
	h.privacyConfig.ConsumeBudget(cost)

	return nil
}

// GetDocument retrieves a document by ID
func (h *HANADocumentStore) GetDocument(ctx context.Context, docID string, userID, sessionID string) (*Document, error) {
	// Check privacy budget
	cost := PrivacyBudgetCosts.DocumentAdd * 0.1 // Lower cost for retrieval
	if !h.privacyConfig.CanPerformOperation(cost) {
		return nil, fmt.Errorf("privacy budget would be exceeded")
	}

	// Get document
	row := h.db.QueryRowContext(ctx, `
		SELECT id, content, metadata, privacy_level, created_at, updated_at, access_count, last_accessed
		FROM documents
		WHERE id = ?
	`, docID)

	var doc Document
	var contentBuf, metadataBuf bytes.Buffer
	var lastAccessed sql.NullTime
	contentLob := hdbdriver.NewLob(nil, &contentBuf)
	metadataLob := hdbdriver.NewLob(nil, &metadataBuf)

	err := row.Scan(&doc.ID, contentLob, metadataLob, &doc.PrivacyLevel, &doc.CreatedAt, &doc.UpdatedAt, &doc.AccessCount, &lastAccessed)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("document not found: %s", docID)
		}
		return nil, fmt.Errorf("failed to get document: %w", err)
	}

	// Populate content and metadata
	doc.Content = contentBuf.String()
	if metadataBuf.Len() > 0 {
		_ = json.Unmarshal(metadataBuf.Bytes(), &doc.Metadata)
	}

	// Set last accessed time
	if lastAccessed.Valid {
		doc.LastAccessed = lastAccessed.Time
	}

	// Update access count and last accessed time
	_, err = h.db.ExecContext(ctx, `
		UPDATE documents 
		SET access_count = access_count + 1, last_accessed = CURRENT_TIMESTAMP
		WHERE id = ?
	`, docID)
	if err != nil {
		// Log error but don't fail the operation
		fmt.Printf("Warning: failed to update access count: %v\n", err)
	}

	// Log access for privacy audit
	h.logDocumentAccess(ctx, docID, userID, sessionID, "read", cost)

	// Update privacy budget
	h.privacyConfig.ConsumeBudget(cost)

	return &doc, nil
}

// UpdateDocument updates a document
func (h *HANADocumentStore) UpdateDocument(ctx context.Context, doc *Document, userID, changeReason string) error {
	// Check privacy budget
	cost := PrivacyBudgetCosts.DocumentAdd
	if !h.privacyConfig.CanPerformOperation(cost) {
		return fmt.Errorf("privacy budget would be exceeded")
	}

	// Serialize metadata
	metadataJSON, err := json.Marshal(doc.Metadata)
	if err != nil {
		return fmt.Errorf("failed to serialize metadata: %w", err)
	}

	// Update document
	_, err = h.db.ExecContext(ctx, `
		UPDATE documents 
		SET content = ?, metadata = ?, privacy_level = ?, updated_at = CURRENT_TIMESTAMP
		WHERE id = ?
	`, doc.Content, string(metadataJSON), doc.PrivacyLevel, doc.ID)

	if err != nil {
		return fmt.Errorf("failed to update document: %w", err)
	}

	// Store version for audit trail
	_, err = h.db.ExecContext(ctx, `
		INSERT INTO document_versions (document_id, content, metadata, privacy_level, created_by, change_reason)
		VALUES (?, ?, ?, ?, ?, ?)
	`, doc.ID, doc.Content, string(metadataJSON), doc.PrivacyLevel, userID, changeReason)

	if err != nil {
		return fmt.Errorf("failed to store document version: %w", err)
	}

	// Log access for privacy audit
	h.logDocumentAccess(ctx, doc.ID, userID, "", "update", cost)

	// Update privacy budget
	h.privacyConfig.ConsumeBudget(cost)

	return nil
}

// DeleteDocument deletes a document
func (h *HANADocumentStore) DeleteDocument(ctx context.Context, docID string, userID string) error {
	// Check privacy budget
	cost := PrivacyBudgetCosts.DocumentAdd * 0.5 // Lower cost for deletion
	if !h.privacyConfig.CanPerformOperation(cost) {
		return fmt.Errorf("privacy budget would be exceeded")
	}

	// Soft delete by updating privacy level
	_, err := h.db.ExecContext(ctx, `
		UPDATE documents 
		SET privacy_level = 'deleted', updated_at = CURRENT_TIMESTAMP
		WHERE id = ?
	`, docID)

	if err != nil {
		return fmt.Errorf("failed to delete document: %w", err)
	}

	// Store version for audit trail
	_, err = h.db.ExecContext(ctx, `
		INSERT INTO document_versions (document_id, content, metadata, privacy_level, created_by, change_reason)
		VALUES (?, '', '{}', 'deleted', ?, 'document_deleted')
	`, docID, userID)

	if err != nil {
		return fmt.Errorf("failed to store document version: %w", err)
	}

	// Log access for privacy audit
	h.logDocumentAccess(ctx, docID, userID, "", "delete", cost)

	// Update privacy budget
	h.privacyConfig.ConsumeBudget(cost)

	return nil
}

// ListDocuments lists documents with pagination and privacy filtering
func (h *HANADocumentStore) ListDocuments(ctx context.Context, privacyLevel string, offset, limit int) ([]*Document, error) {
	var query string
	var args []interface{}

	if privacyLevel != "" {
		query = `
			SELECT id, content, metadata, privacy_level, created_at, updated_at, access_count, last_accessed
			FROM documents
			WHERE privacy_level = ?
			ORDER BY created_at DESC
			LIMIT ? OFFSET ?
		`
		args = []interface{}{privacyLevel, limit, offset}
	} else {
		query = `
			SELECT id, content, metadata, privacy_level, created_at, updated_at, access_count, last_accessed
			FROM documents
			WHERE privacy_level != 'deleted'
			ORDER BY created_at DESC
			LIMIT ? OFFSET ?
		`
		args = []interface{}{limit, offset}
	}

	rows, err := h.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to list documents: %w", err)
	}
	defer rows.Close()

	var documents []*Document
	for rows.Next() {
		var doc Document
		var contentBuf, metadataBuf bytes.Buffer
		var lastAccessed sql.NullTime
		contentLob := hdbdriver.NewLob(nil, &contentBuf)
		metadataLob := hdbdriver.NewLob(nil, &metadataBuf)

		if err := rows.Scan(&doc.ID, contentLob, metadataLob, &doc.PrivacyLevel, &doc.CreatedAt, &doc.UpdatedAt, &doc.AccessCount, &lastAccessed); err != nil {
			continue
		}

		doc.Content = contentBuf.String()
		if metadataBuf.Len() > 0 {
			_ = json.Unmarshal(metadataBuf.Bytes(), &doc.Metadata)
		}

		if lastAccessed.Valid {
			doc.LastAccessed = lastAccessed.Time
		}

		documents = append(documents, &doc)
	}

	return documents, nil
}

// SearchDocuments searches documents by content with privacy controls
func (h *HANADocumentStore) SearchDocuments(ctx context.Context, query string, privacyLevel string, limit int) ([]*Document, error) {
	// Check privacy budget
	cost := PrivacyBudgetCosts.SearchQuery
	if !h.privacyConfig.CanPerformOperation(cost) {
		return nil, fmt.Errorf("privacy budget would be exceeded")
	}

	var sqlQuery string
	var args []interface{}

	if privacyLevel != "" {
		sqlQuery = `
			SELECT id, content, metadata, privacy_level, created_at, updated_at, access_count, last_accessed
			FROM documents
			WHERE privacy_level = ? AND content LIKE ?
			ORDER BY created_at DESC
			LIMIT ?
		`
		args = []interface{}{privacyLevel, "%" + query + "%", limit}
	} else {
		sqlQuery = `
			SELECT id, content, metadata, privacy_level, created_at, updated_at, access_count, last_accessed
			FROM documents
			WHERE privacy_level != 'deleted' AND content LIKE ?
			ORDER BY created_at DESC
			LIMIT ?
		`
		args = []interface{}{"%" + query + "%", limit}
	}

	rows, err := h.db.QueryContext(ctx, sqlQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to search documents: %w", err)
	}
	defer rows.Close()

	var documents []*Document
	for rows.Next() {
		var doc Document
		var contentBuf, metadataBuf bytes.Buffer
		var lastAccessed sql.NullTime
		contentLob := hdbdriver.NewLob(nil, &contentBuf)
		metadataLob := hdbdriver.NewLob(nil, &metadataBuf)

		if err := rows.Scan(&doc.ID, contentLob, metadataLob, &doc.PrivacyLevel, &doc.CreatedAt, &doc.UpdatedAt, &doc.AccessCount, &lastAccessed); err != nil {
			continue
		}

		doc.Content = contentBuf.String()
		if metadataBuf.Len() > 0 {
			_ = json.Unmarshal(metadataBuf.Bytes(), &doc.Metadata)
		}

		if lastAccessed.Valid {
			doc.LastAccessed = lastAccessed.Time
		}

		documents = append(documents, &doc)
	}

	// Update privacy budget
	h.privacyConfig.ConsumeBudget(cost)

	return documents, nil
}

// GetDocumentStats returns document statistics
func (h *HANADocumentStore) GetDocumentStats(ctx context.Context) (map[string]interface{}, error) {
	rows, err := h.db.QueryContext(ctx, `
		SELECT 
			privacy_level,
			COUNT(*) as count,
			AVG(LENGTH(content)) as avg_content_length,
			SUM(access_count) as total_accesses
		FROM documents
		WHERE privacy_level != 'deleted'
		GROUP BY privacy_level
	`)
	if err != nil {
		return nil, fmt.Errorf("failed to get document stats: %w", err)
	}
	defer rows.Close()

	stats := map[string]interface{}{
		"by_privacy_level": make(map[string]interface{}),
	}

	for rows.Next() {
		var privacyLevel string
		var count, avgLength, totalAccesses sql.NullFloat64

		err := rows.Scan(&privacyLevel, &count, &avgLength, &totalAccesses)
		if err != nil {
			continue
		}

		stats["by_privacy_level"].(map[string]interface{})[privacyLevel] = map[string]interface{}{
			"count":              count.Float64,
			"avg_content_length": avgLength.Float64,
			"total_accesses":     totalAccesses.Float64,
		}
	}

	return stats, nil
}

// CleanupOldDocuments removes old documents based on retention policy
func (h *HANADocumentStore) CleanupOldDocuments(ctx context.Context) error {
	cutoffDate := time.Now().AddDate(0, 0, -h.privacyConfig.RetentionDays)

	// Clean up old document versions
	_, err := h.db.ExecContext(ctx, `
		DELETE FROM document_versions WHERE created_at < ?
	`, cutoffDate)
	if err != nil {
		return fmt.Errorf("failed to cleanup document versions: %w", err)
	}

	// Clean up old access logs
	_, err = h.db.ExecContext(ctx, `
		DELETE FROM document_access_log WHERE timestamp < ?
	`, cutoffDate)
	if err != nil {
		return fmt.Errorf("failed to cleanup access logs: %w", err)
	}

	return nil
}

// logDocumentAccess logs document access for privacy audit
func (h *HANADocumentStore) logDocumentAccess(ctx context.Context, docID, userID, sessionID, accessType string, privacyCost float64) {
	userIDHash := AnonymizeString(userID)

	_, err := h.db.ExecContext(ctx, `
		INSERT INTO document_access_log (document_id, user_id_hash, session_id, access_type, privacy_budget_used)
		VALUES (?, ?, ?, ?, ?)
	`, docID, userIDHash, sessionID, accessType, privacyCost)

	if err != nil {
		// Log error but don't fail the operation
		fmt.Printf("Warning: failed to log document access: %v\n", err)
	}
}

// Close closes the database connection
func (h *HANADocumentStore) Close() error {
	return h.db.Close()
}
