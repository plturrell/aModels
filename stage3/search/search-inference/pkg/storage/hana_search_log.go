//go:build hana

package storage

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"time"
)

// HANASearchLogger provides search logging with privacy controls
type HANASearchLogger struct {
	db            *sql.DB
	privacyConfig *PrivacyConfig
}

// NewHANASearchLogger creates a new HANA search logger
func NewHANASearchLogger(dsn string, privacyConfig *PrivacyConfig) (*HANASearchLogger, error) {
	db, err := sql.Open("hdb", dsn)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to HANA: %w", err)
	}

	logger := &HANASearchLogger{
		db:            db,
		privacyConfig: privacyConfig,
	}

	// Create tables if they don't exist
	if err := logger.createTables(); err != nil {
		return nil, fmt.Errorf("failed to create tables: %w", err)
	}

	return logger, nil
}

// createTables creates the necessary HANA tables for search logging
func (h *HANASearchLogger) createTables() error {
	ctx := context.Background()

	createLogs := `
CREATE COLUMN TABLE search_logs (
	id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	query_hash NVARCHAR(64) NOT NULL,
	query_embedding BLOB,
	result_count INTEGER NOT NULL,
	top_result_id NVARCHAR(255),
	latency_ms BIGINT NOT NULL,
	user_id_hash NVARCHAR(64),
	session_id NVARCHAR(255),
	timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	privacy_budget_used DECIMAL(10,6) NOT NULL
)`
	if _, err := h.db.ExecContext(ctx, createLogs); err != nil && !isAlreadyExistsError(err) {
		return fmt.Errorf("failed to create search_logs table: %w", err)
	}

	createClicks := `
CREATE COLUMN TABLE search_clicks (
	id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	query_hash NVARCHAR(64) NOT NULL,
	document_id NVARCHAR(255) NOT NULL,
	position INTEGER DEFAULT 0,
	timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	session_id NVARCHAR(255)
)`
	if _, err := h.db.ExecContext(ctx, createClicks); err != nil && !isAlreadyExistsError(err) {
		return fmt.Errorf("failed to create search_clicks table: %w", err)
	}

	indexes := []string{
		"CREATE INDEX idx_search_logs_query_hash ON search_logs (query_hash)",
		"CREATE INDEX idx_search_logs_timestamp ON search_logs (timestamp)",
		"CREATE INDEX idx_search_clicks_query_hash ON search_clicks (query_hash)",
	}

	for _, stmt := range indexes {
		if _, err := h.db.ExecContext(ctx, stmt); err != nil && !isAlreadyExistsError(err) {
			fmt.Printf("⚠️  Index creation failed: %v\n", err)
		}
	}

	return nil
}

// LogSearch logs a search query with privacy controls
func (h *HANASearchLogger) LogSearch(ctx context.Context, searchLog *SearchLog) error {
	if h.privacyConfig == nil {
		return fmt.Errorf("privacy configuration not set")
	}
	// Check privacy budget
	cost := PrivacyBudgetCosts.SearchLog
	if !h.privacyConfig.CanPerformOperation(cost) {
		return fmt.Errorf("privacy budget would be exceeded")
	}

	// Insert search log
	_, err := h.db.ExecContext(ctx, `
		INSERT INTO search_logs (query_hash, query_embedding, result_count, top_result_id, latency_ms, user_id_hash, session_id, timestamp, privacy_budget_used)
		VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
	`, searchLog.QueryHash, h.embeddingToBytes(searchLog.QueryEmbedding), searchLog.ResultCount, searchLog.TopResultID, searchLog.LatencyMs, searchLog.UserIDHash, searchLog.SessionID, searchLog.Timestamp, searchLog.PrivacyBudgetUsed)

	if err != nil {
		return fmt.Errorf("failed to log search: %w", err)
	}

	// Update privacy budget
	if err := h.privacyConfig.ConsumeBudget(cost); err != nil {
		return err
	}

	return nil
}

// LogClick logs a click-through event
func (h *HANASearchLogger) LogClick(ctx context.Context, queryHash, documentID string, position int, sessionID string) error {
	if h.privacyConfig == nil {
		return fmt.Errorf("privacy configuration not set")
	}
	// Check privacy budget
	cost := PrivacyBudgetCosts.ClickLog
	if !h.privacyConfig.CanPerformOperation(cost) {
		return fmt.Errorf("privacy budget would be exceeded")
	}

	// Insert click log
	_, err := h.db.ExecContext(ctx, `
		INSERT INTO search_clicks (query_hash, document_id, position, timestamp, session_id)
		VALUES (?, ?, ?, ?, ?)
	`, queryHash, documentID, position, time.Now(), sessionID)

	if err != nil {
		return fmt.Errorf("failed to log click: %w", err)
	}

	// Update privacy budget
	if err := h.privacyConfig.ConsumeBudget(cost); err != nil {
		return err
	}

	return nil
}

// GetSearchAnalytics returns search analytics with privacy controls
func (h *HANASearchLogger) GetSearchAnalytics(ctx context.Context, startTime, endTime time.Time) (map[string]interface{}, error) {
	if h.privacyConfig == nil {
		return nil, fmt.Errorf("privacy configuration not set")
	}
	// Check privacy budget
	cost := PrivacyBudgetCosts.AnalyticsQuery
	if !h.privacyConfig.CanPerformOperation(cost) {
		return nil, fmt.Errorf("privacy budget would be exceeded")
	}

	// Query search statistics
	var totalSearches int
	err := h.db.QueryRowContext(ctx, `
		SELECT COUNT(*) FROM search_logs 
		WHERE timestamp BETWEEN ? AND ?
	`, startTime, endTime).Scan(&totalSearches)
	if err != nil {
		return nil, fmt.Errorf("failed to get total searches: %w", err)
	}

	var avgLatency float64
	err = h.db.QueryRowContext(ctx, `
		SELECT AVG(latency_ms) FROM search_logs 
		WHERE timestamp BETWEEN ? AND ?
	`, startTime, endTime).Scan(&avgLatency)
	if err != nil {
		return nil, fmt.Errorf("failed to get average latency: %w", err)
	}

	var totalClicks int
	err = h.db.QueryRowContext(ctx, `
		SELECT COUNT(*) FROM search_clicks 
		WHERE timestamp BETWEEN ? AND ?
	`, startTime, endTime).Scan(&totalClicks)
	if err != nil {
		return nil, fmt.Errorf("failed to get total clicks: %w", err)
	}

	// Update privacy budget
	if err := h.privacyConfig.ConsumeBudget(cost); err != nil {
		return nil, err
	}

	return map[string]interface{}{
		"total_searches": totalSearches,
		"avg_latency_ms": avgLatency,
		"total_clicks":   totalClicks,
		"click_through_rate": func() float64 {
			if totalSearches == 0 {
				return 0.0
			}
			return float64(totalClicks) / float64(totalSearches)
		}(),
	}, nil
}

// embeddingToBytes converts an embedding vector to bytes for storage
func (h *HANASearchLogger) embeddingToBytes(embedding []float64) []byte {
	data, _ := json.Marshal(embedding)
	return data
}

// Close closes the database connection
func (h *HANASearchLogger) Close() error {
	return h.db.Close()
}
